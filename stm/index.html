<!DOCTYPE html>
<html lang="zh">

<!--
    Edit Date & time
    {   
        ST2P:
            2021/05/06 - 20:11
            2021/05/07 - 23:44
            2021/05/08 - 00:02
        STM:
            2021/05/26 - 14:07
            2021/05/26 - 14:49
            2021/05/27 - 11:36
			2021/06/25 - 15:04
			2021/06/30 - 20:11
			2021/07/01 - 14:54
			2021/07/01 - 21:06
            2021/07/21 - 13:21
    }
-->

<head>
    <meta charset="utf-8" name="viewport" content="minimum-scale=0">
    <title>ShadowlessTankMult</title>
    <style>
        img {
            max-width: 80%;
            max-height: 80%;
        }

        video {
            width: 80%;
            height: 80%;
        }

        input {
            font-size: 40px;

        }

        p {
            font-size: 20px;
        }

        select {
            font-size: 40px;
            width: 100px;
        }

        button {
            width: 300px;
            height: 50px;
        }

        body {
            font-size: 28px;
        }

        .brand {
            margin-left: 20px;
            margin-right: 50px;
            margin-top: 25px;
            margin-bottom: 0px;
            color: rgb(255, 255, 255);

        }

        ul.nav {
            list-style-type: none;
            margin-top: 0px;
            margin-left: -16px;
            padding: -40px 0px;
            overflow: hidden;
            background-color: rgba(24, 24, 24, 0.75);
            position: fixed;
            top: 0;
            width: 100%;
        }

        ul.nav li {
            float: left;
            border-right: 5px rgba(255, 255, 255, 0.75);
        }

        ul.nav li a {
            display: block;
            color: white;
            text-align: center;
            padding: 40px 50px;
            text-decoration: none;
        }

        ul.nav li a:hover {
            background-color: rgb(150, 150, 150);
        }

        ul.nav li a.active {
            background-color: rgba(8, 250, 0, 0.75);
        }
    </style>

</head>

<body>

    <ul id="NAV" class="nav">
        <li>
            <h1 class='brand'>STM</h1>
        </li>
        <li><a id="NAVhome" href="javascript:;" onclick="changePage('NAVhome')"><big>主页</big></a></li>
        <li><a id="NAVinfo" href="javascript:;" onclick="changePage('NAVinfo')"><big>信息</big></a></li>
        <li><a id="NAVentk" href="javascript:;" onclick="changePage('NAVentk')"><big>构造</big></a></li>
        <li><a id="NAVdetk" href="javascript:;" onclick="changePage('NAVdetk')"><big>解除</big></a></li>
    </ul>

    <br /><br /><br />

    <div id="home" style="display: none;">
        <h1> 无影坦克集群 </h1>
        <br />
        <span style="color:#ee6622">
            <span style="font-weight:bold">免责声明</span> 
            本程序仅供技术研究使用，若您将该程序用于非法行为，由此所致的法律后果由您自行承担！
        </span>
        <br />
        <br />
        <span>说明(劳烦注意看一下)</span>
        <br /><br />
        <span>多选文件因设备和软件各异，手机端可能要长按触发多选模式，电脑端可使用框选或ctrl键加单点精确多选</span>
        <br /><br />
        <span>本网页不使用后端，可下载至本地设备离线使用</span>
        <br /><br />
        <span>原理是lsb隐写，不是类似图种的东西，压缩软件打不开的</span>
        <br /><br />
        <span>百度贴吧会自动压缩大图，所以里图大小建议不要过大，百度贴吧ios端似乎对所有图片都压缩，导致ios发不成功</span>
        <br /><br />
        <span>建议不要在百度浏览器或贴吧自带浏览器内使用此程序</span>
        <br /><br />
        <span>部分浏览器使用时可能会因为兼容性问题导致无法保存图片，建议换谷歌浏览器</span>
        <br />
        <br />
        <br />
        下载此网页文件：
        <a id="doc" download="STM.html">[下载]</a>&ensp;
        <br />
        下载原作者的原文件(外链):
        <a href="https://github.com/wytk/wytk.github.io/archive/main.zip">[下载]</a><br />
        下载之后是个html文件，(大概)可以用浏览器直接打开使用
    </div>

    <div id="info" style="display: none;">
        <br>
        <p id="path" style="max-width: 90%; max-height: auto;">path not found</p>
        <br />
        <p id="agent" style="max-width: 90%; max-height: auto;">userAgent not found</p>
        <br />
        <hr />
        <br />
        <div id="logger"></div>
    </div>

    <div id="entk" style="display: none;">

        <br />
        <span>选择表图(可多选)</span>
        <br />
        <input type="file" id="outSide" onchange="outsidePlace()" accept="image/*" multiple="">
        <br />
        <br />
        <span>选择里件(可多选)</span>
        <br />
        <input type="file" id="inSide" onchange="insidePlace()" multiple="">
        <br />
        <br />
        <span><big>隐写位数</big></span>
        <select id="select">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4" selected="true">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
        </select>
        <br>
        <span>隐写位数越高坦克越小，但图像色彩噪点越多</span>
        <br>
        <span>"压缩度"这个不恰当文案已被更改，但其他工厂可能仍在使用</span>
        <br>
        <span>并不是所有的工厂都支持解5位以上隐写位数坦克，尤其是老工厂</span>
        <br>
        <br />
        <span>图片左上角添加备注</span><input id="addNote" style="width: 20px; height: 20px;" type="checkbox" checked="true">
        <br />
        <input type="text" id="textNote" style="width:400px" value="STM">
        <br />
        <span>图片右上角添加编号</span><input id="addNum" style="width: 20px; height: 20px;" type="checkbox" checked="true">
        <br />
        <br />
        <span>自定义坦克文件名(自动添加后缀)</span>
        <br />
        <input type="text" id="TKFname" style="width:400px" value="download">
        <br />
        <span>文件名后加编号</span><input id="nkfnNumed" style="width: 20px; height: 20px;" type="checkbox" checked="true">
        <br />
        <br />
        <span>如果您要将坦克上传至社交平台,请确保您上传的是原图且没有任何水印</span>
        <br />
        <br />
        <button onclick="enAction()">合成图片</button><button onclick="enAllDownload()">全部下载</button>
        <hr />
        <div id="enWindow"></div>
        <hr />
    </div>

    <div id="detk" style="display: none;">
        <br />
        <span>选择坦克(可多选)</span>
        <br />
        <input type="file" id="deImg" onchange="deimgPlace()" accept="image/*" multiple="">
        <br />
        <span>如果您的图片是从社交平台得到，请确定您下载的是原图</span>
        <br />
        <br />
        <button onclick="deAction()">解除图片</button><button onclick="deAllDownload()">全部下载</button>
        <hr />
        <div id="deWindow"></div>
        <hr />
    </div>

</body>

<script type="text/javascript">

    var osArray = [];     //  outsidePlace()    enAction()
    var isArray = [];     //  insidePlace()     enAction()
    var diArray = [];     //  deimgPlace()      deAction()

    var enUrlArray = [];  //  enAllDownload()   multEnTask()
    var deUrlArray = [];  //  deAllDownload()   multDeTask()

    /* ------------------------------------------------------------------------------------- */

    window.onload = function () {
        let w = "<!DOCTYPE " + "html>" + document.documentElement.outerHTML;
        document.getElementById("doc").href = URL.createObjectURL(new Blob([w], { type: "text/html" }))
    }

    try {

        let sizeError = false;
        if (document.documentElement.clientWidth < 900) {
            document.documentElement.style.width = "900px";
            sizeError = true;
        }
        if (document.documentElement.clientHeight < 1600) {
            document.documentElement.style.height = "1600px";
            sizeError = true;
        }
        if (sizeError)
            alert("已尝试修复由默认长宽度产生的异常排版问题，若手机浏览器显示异常仍然存在，可尝试切换到电脑版视图模式");

        document.getElementById("NAVhome").classList.add("active");
        document.getElementById("home").style.display = "block";
        document.getElementById("path").innerText = window.location.href;
        document.getElementById("agent").innerText = navigator.userAgent;
    }
    catch (e) {
        alert(e.stack);
    }

    /* ------------------------------------------------------------------------------------- */

    function changePage(id) {
        if (typeof (id) != "string")
            throw new Error("id type is not [string]");
        let navs = ["NAVhome", "NAVinfo", "NAVentk", "NAVdetk"];
        for (i = 0; i < navs.length; i++) {
            document.getElementById(navs[i]).classList.remove("active");
            document.getElementById(navs[i].slice(3)).style.display = "none";
        }
        document.getElementById(id).classList.add("active");
        document.getElementById(id.slice(3)).style.display = "block";
    }

    function outsidePlace() {


        let fs = document.getElementById("outSide").files;

        osArray = new Array(fs.length);

        for (i = 0; i < fs.length; i++) {
            let fr = new MarkFileReader(i);
            fr.onloadend = (event) => {
                let img = new Image();
                img.src = event.target.result;
                osArray[fr.mark] = { data: img, name: fs[fr.mark].name };
                toLog("logger").log("outsidePlace " + fr.mark + " " + osArray[fr.mark].name);
            }
            fr.readAsDataURL(fs[i]);
        }


    }

    function insidePlace() {

        let fs = document.getElementById("inSide").files;

        isArray = new Array(fs.length);

        for (i = 0; i < fs.length; i++) {
            let n = fs[i].name;
            let t = fs[i].type;
            let fr = new MarkFileReader(i);
            fr.onloadend = (event) => {
                let l = new Uint8Array(event.target.result);
                isArray[fr.mark] = [[l.length, utf8Encode(n), t], l];
                toLog("logger").log("insidePlace " + fr.mark + " " + isArray[fr.mark][0][2]);
            };
            fr.readAsArrayBuffer(fs[i]);
        }

    }

    function deimgPlace() {

        let fs = document.getElementById("deImg").files;

        diArray = new Array(fs.length);

        for (i = 0; i < fs.length; i++) {
            let fr = new MarkFileReader(i);
            fr.onloadend = (event) => {
                let img = new Image();
                img.src = event.target.result;
                diArray[fr.mark] = { data: img, name: fs[fr.mark].name };
                toLog("logger").log("deimgPlace " + fr.mark + " " + diArray[fr.mark].name);
            };
            fr.readAsDataURL(fs[i]);
        }

    }

    function enAction() {
        try { multEnTask(osArray, isArray, document.getElementById("enWindow")); }
        catch (e) {
            alert(e.stack);
            toLog("logger").log(e.stack);
            throw e;
        }
    }

    function deAction() {
        try { multDeTask(diArray, document.getElementById("deWindow")); }
        catch (e) {
            alert(e.stack);
            toLog("logger").log(e.stack);
            throw e;
        }
    }

    function enAllDownload() {

        for (i = 0; i < enUrlArray.length; i++) {
            if (enUrlArray[i] == null)
                continue;
            let sn = i;
            let todo = document.createElement("a");
            todo.href = enUrlArray[i];
            let name = document.getElementById("TKFname").value;
            if (document.getElementById("nkfnNumed").checked)
                name += "(" + (i + 1) + "_" + enUrlArray.length + ")";
            todo.download = name;
            setTimeout(function () {
                todo.click();
                toLog("logger").log("enAllDownload " + sn + " click actived");
            }, i * 500);
        }

    }

    function deAllDownload() {

        for (i = 0; i < deUrlArray.length; i++) {
            if (deUrlArray[i] == null)
                continue;
            let sn = i;
            let todo = document.createElement("a");
            todo.href = deUrlArray[i];
            todo.download = "";
            setTimeout(function () {
                todo.click();
                toLog("logger").log("deAllDownload " + sn + " click actived");
            }, i * 500);
        }

    }



    /* ------------------------------------------------------------------------------------- */


    function multEnTask(outsideArray, insideArray, hostWindow) {

        if (outsideArray.length == 0 || insideArray.length == 0)
            throw new Error("表图片或里文件数量为0");


        hostWindow.innerHTML = "";

        for (i = 0; i < enUrlArray.length; i++) { URL.revokeObjectURL(enUrlArray[i]); }
        enUrlArray = new Array(insideArray.length);

        let osn = 0;


        for (i = 0; i < insideArray.length; i++) {


            if (osn >= outsideArray.length) { osn = 0; }

            let div = document.createElement("div");

            div.name = "enSubWindow";
            hostWindow.appendChild(div);
            div.appendChild(document.createElement("hr"));

            let msize = ((insideArray[i][1]).length / 1024 / 1024);


            let mode = parseInt(document.getElementById("select").value);


            let displayOutsideName = document.createElement("p");
            displayOutsideName.innerText = "表图名称: " + outsideArray[osn].name;
            div.appendChild(displayOutsideName);

            let displayInsideName = document.createElement("p");
            displayInsideName.innerText = "里件名称:  " + utf8Decode(insideArray[i][0][1]);
            div.appendChild(displayInsideName);

            let displayMode = document.createElement("p");
            displayMode.innerText = "使用隐写位数:  " + mode;
            div.appendChild(displayMode);


            let ian = i;
            let outCanvas = drawImage(mode, outsideArray[osn].data, insideArray[i], "(" + (i + 1) + "/" + insideArray.length + ")");
            let imgd;
            try {
                imgd = outCanvas.getContext("2d").getImageData(0, 0, outCanvas.width, outCanvas.height);
            }
            catch (e) {
                let m = e.message;
                if (m.indexOf("Out of memory") != -1) {
                    let displayOOM = document.createElement("p");
                    displayOOM.innerText = "超出内存，当前在这个设备上程序无法执行这个任务";
                    div.appendChild(displayOOM);
                }

                let displayErrorStack = document.createElement("p");
                displayErrorStack.innerText = e.stack;
                div.appendChild(displayErrorStack);

                continue;
            }

            let package = {
                sn: ian,
                mode: mode,
                data: imgd,
                insideHead: insideArray[ian][0].join(String.fromCharCode(1)) + String.fromCharCode(0),
                insideData: insideArray[ian][1]
            }
            let w = createWorker(enWorker);

            w.onmessage = (event) => {

                if (event.data.error != null) {
                    let errText = document.createElement("p");
                    errText.innerText = "发生错误: " + event.data.error.stack;
                    div.appendChild(errText);
                    w.terminate();
                    toLog("logger").log("enWorker [" + event.data.sn + "] end with error");
                    return;
                }

                let tkCanvas = document.createElement("canvas");
                tkCanvas.width = event.data.value.width;
                tkCanvas.height = event.data.value.height;
                tkCanvas.getContext("2d").putImageData(event.data.value, 0, 0);

                tkCanvas.toBlob((blob) => {

                    let displayTKsize = document.createElement("p");
                    displayTKsize.innerText = "坦克大小: " + (blob.size / 1024).toFixed(3) + "KB" + "  或  " + (blob.size / 1024 / 1024).toFixed(3) + "MB";
                    div.appendChild(displayTKsize);

                    let displayWorkerTime = document.createElement("p");
                    displayWorkerTime.innerText = "线程耗时: " + event.data.time + " ms";
                    div.appendChild(displayWorkerTime);

                    let url = URL.createObjectURL(blob);
                    enUrlArray[event.data.sn] = url;
                    let displayImage = document.createElement("img");
                    displayImage.src = url;
                    div.appendChild(displayImage);
                    toLog("logger").log("enWorker [" + event.data.sn + "] end with success");

                }, "image/png");

                w.terminate();

            };
            try {
                w.postMessage(package);
            }
            catch (e) {
                let m = e.message;
                if (m.indexOf("Out of memory") != -1) {
                    let displayOOM = document.createElement("p");
                    displayOOM.innerText = "超出内存，当前在这个设备上程序无法执行这个任务";
                    div.appendChild(displayOOM);
                }

                let displayErrorStack = document.createElement("p");
                displayErrorStack.innerText = e.stack;
                div.appendChild(displayErrorStack);

                continue;
            }
            toLog("logger").log("enWorker [" + i + "] actived");

            osn++;

        }
    }

    function drawImage(mode, outside, inside, numstring) {

        let word = inside[0].join(String.fromCharCode(1)) + String.fromCharCode(0);
        let length = 2 + parseInt((word.length + inside[1].length) * 8 / (mode * 3))
        let ax = Math.sqrt(length / (outside.width * outside.height));
        let wid = Math.ceil(outside.width * ax);
        let hit = Math.ceil(outside.height * ax);

        if (wid < 300) {
            wid = 300;
            hit = Math.ceil(300 * (outside.height / outside.width));
        }

        let cv = document.createElement("canvas");
        let cvd = cv.getContext("2d");

        cv.width = wid;
        cv.height = hit;

        cvd.fillStyle = "#ffffff";
        cvd.fillRect(0, 0, wid, hit);
        cvd.drawImage(outside, 0, 0, wid, hit);



        if (document.getElementById("addNote").checked) {
            let w = document.getElementById("textNote").value;
            cvd.font = "16px Arial";
            cvd.textBaseline = "middle";
            cvd.fillStyle = "rgba(255,255,255,0.75)";
            cvd.fillRect(0, 0, cvd.measureText(w).width + 8, 28);
            cvd.fillStyle = "#000000";
            cvd.fillText(w, 4, 14, wid - 8);
        }

        if (document.getElementById("addNum").checked) {
            let w = numstring;
            cvd.font = "16px Arial";
            cvd.textBaseline = "middle";
            cvd.fillStyle = "rgba(255,255,255,0.75)";
            let mt = cvd.measureText(w).width;
            cvd.fillRect(cv.width - (mt + 8), 0, mt + 8, 28);
            cvd.fillStyle = "#000000";
            cvd.fillText(w, cv.width - (mt + 5), 14, wid - 8);
        }



        return cv;

    }

    function multDeTask(deimgArray, hostWindow) {

        if (deimgArray.length == 0)
            throw new Error("解图文件数量为0");


        hostWindow.innerHTML = "";

        for (i = 0; i < deUrlArray.length; i++) { URL.revokeObjectURL(deUrlArray[i]); }
        deUrlArray = new Array(deimgArray.length);

        for (i = 0; i < deimgArray.length; i++) {

            let div = document.createElement("div");

            div.name = "deSubWindow";
            hostWindow.appendChild(div);
            div.appendChild(document.createElement("hr"));

            let displayDeimgName = document.createElement("p");
            displayDeimgName.innerText = "坦克文件名: " + deimgArray[i].name;
            div.appendChild(displayDeimgName);

            let cv = document.createElement("canvas");
            let cvd = cv.getContext("2d");
            let img = deimgArray[i].data;



            cv.width = img.width;
            cv.height = img.height;
            cvd.drawImage(img, 0, 0);

            let imgdata;
            try {
                imgdata = cvd.getImageData(0, 0, img.width, img.height);
            }
            catch (e) {
                let m = e.message;
                if (m.indexOf("Out of memory") != -1) {
                    let displayOOM = document.createElement("p");
                    displayOOM.innerText = "超出内存，当前在这个设备上程序无法执行这个任务";
                    div.appendChild(displayOOM);
                }

                let displayErrorStack = document.createElement("p");
                displayErrorStack.innerText = e.stack;
                div.appendChild(displayErrorStack);

                continue;
            }

            if (imgdata.data[0] % 8 != 0 || imgdata.data[1] % 8 != 3) {
                let displayCannotDecode = document.createElement("p");
                displayCannotDecode.innerText = "未找到标识头，可能不是坦克或坦克已损坏";
                div.appendChild(displayCannotDecode);
                continue;
            }

            if (imgdata.data[2] % 8 < 1 || imgdata.data[2] % 8 > 7) {
                let displayCannotDecode = document.createElement("p");
                displayCannotDecode.innerText = "标识的隐写位超出预定范围";
                div.appendChild(displayCannotDecode);
                continue;
            }

            let sel = imgdata.data[2] % 8;

            let displayMode = document.createElement("p");
            displayMode.innerText = "坦克隐写位数: " + sel;
            div.appendChild(displayMode);

            let ian = i;

            let package = {
                sn: ian,
                mode: sel,
                data: imgdata
            };

            let w = createWorker(deWorker);

            w.onmessage = (event) => {

                if (event.data.error != null) {
                    let errText = document.createElement("p");
                    errText.innerText = "发生错误: " + event.data.error.stack;
                    div.appendChild(errText);
                    w.terminate();
                    toLog("logger").log("deWorker [" + event.data.sn + "] end with error");
                    return;
                }

                let klist = event.data.value;
                let name = utf8Decode(klist[0][1]);
                let type = enumCompleType(name, klist[0][2]);

                let f = new File([klist[1]], name, { type: type });
                let url = URL.createObjectURL(f);

                deUrlArray[event.data.sn] = url;

                let displayInsideName = document.createElement("p");
                let displayInsideType = document.createElement("p");
                let displayInsideSize = document.createElement("p");

                displayInsideName.innerText = "里文件名: " + name;
                displayInsideType.innerText = "里文件类型: " + type;
                displayInsideSize.innerText = "里文件大小: " + (f.size / 1024).toFixed(3) + "KB" + "  或  " + (f.size / 1024 / 1024).toFixed(3) + "MB";

                div.appendChild(displayInsideName);
                div.appendChild(displayInsideType);
                div.appendChild(displayInsideSize);


                let displayWorkerTime = document.createElement("p");
                displayWorkerTime.innerText = "线程耗时: " + event.data.time + " ms";
                div.appendChild(displayWorkerTime);

                let toDownload = document.createElement("a");
                toDownload.href = url;
                toDownload.download = "";
                toDownload.innerText = "保存文件";
                div.appendChild(toDownload);

                div.appendChild(document.createElement("br"));

                // 显示图片判断
                if (f.type.indexOf("image/") == 0) {
                    let displayImage = document.createElement("img");
                    displayImage.src = url;
                    div.appendChild(displayImage);
                }

                // 显示视频判断
                if (f.type.indexOf("video/") == 0) {
                    let displayVideo = document.createElement("video");
                    displayVideo.src = url;
                    displayVideo.controls = "controls";
                    div.appendChild(displayVideo);
                }
                toLog("logger").log("deWorker [" + event.data.sn + "] end with success");
                w.terminate();

            }

            try {
                w.postMessage(package);
            }
            catch (e) {
                let m = e.message;
                if (m.indexOf("Out of memory") != -1) {
                    let displayOOM = document.createElement("p");
                    displayOOM.innerText = "超出内存，当前在这个设备上程序无法执行这个任务";
                    div.appendChild(displayOOM);
                }

                let displayErrorStack = document.createElement("p");
                displayErrorStack.innerText = e.stack;
                div.appendChild(displayErrorStack);

                continue;
            }

            toLog("logger").log("deWorker [" + ian + "] actived");
        }

    }


    // 给写不了文件类型的其他工厂擦屁股
    function enumCompleType(name, def) {

        let an = name.split(".");
        let nt = an[an.length - 1];
        switch (nt) {
            case "jpg": return "image/jpg";
            case "jpeg": return "image/jpeg";
            case "png": return "image/png";
            case "webp": return "image/webp";
            case "gif": return "image/gif";
            case "mp4": return "video/mp4";
            case "avi": return "video/avi";
            case "webm": return "video/webm";
            case "mov": return "video/quicktime";
            case "7z": return "application/x-7z-compressed";
            case "rar": return "application/rar";
            case "zip": return "application/zip";
            case "exe": return "application/x-msdos-program";
            case "apk": return "application/vnd.android.package-archive";
            case "html": return "text/html";
            case "txt": return "text/plain";
            default: def;
        }

    }



    /* ------------------------------------------------------------------------------------- */

    function createWorker(tf) {
        if (typeof (tf) != "function")
            throw new Error("value type is not a [function]");
        return new Worker(
            URL.createObjectURL(
                new Blob(
                    ["(" + tf.toString() + ")()"]
                )
            )
        );
    }

    //
    function enWorker() {

        /* 
          closer()函数的可能值
          mode 1~7
          ImageData 0~255
          InsideData 0~127
        */
        const closerArray = (() => {
            let mlist = [1, 2, 4, 8, 16, 32, 64, 128];
            let arrayM = new Array(8); // mode (1~7)
            for (m = 1; m < 8; m++) {  // mode
                let arrayD = new Array(256);
                for (let d = 0; d < 256; d++) {
                    let arrayV = new Array(128);
                    for (let v = 0; v < 128; v++)
                        arrayV[v] = closer(mlist[m], d, v);
                    arrayD[d] = arrayV;
                }
                arrayM[m] = arrayD;
            }
            return arrayM;
        })();

        onmessage = (evt) => {
            let o = evt.data;
            let feedback = { sn: evt.data.sn, value: null, error: null, time: null };
            try {
                let d1 = new Date();
                feedback.value = enCode(o.mode, o.data, o.insideHead, o.insideData);
                let d2 = new Date();
                feedback.time = (d2 - d1);
            }
            catch (e) {
                feedback.error = e;
                console.log(e);
            }
            postMessage(feedback);
        }


        // 编码
        function enCode(mode, imgdata, insideHead, insideData) {

            let dataArray = new Uint8Array(insideHead.length + insideData.length);
            let DAI = 0;

            for (let i = 0; i < insideHead.length; i++) {
                dataArray[DAI] = insideHead.charCodeAt(i);
                DAI++;
            }

            for (let i = 0; i < insideData.length; i++) {
                dataArray[DAI] = insideData[i];
                DAI++;
            }

            let changedArray = changeBitArray(8, mode, dataArray);

            if ((imgdata.width * imgdata.height - 1) * 3 < changedArray.length)
                throw new Error("图像空间无法承载隐写数据");

            imgdata.data[0] = closer(8, imgdata.data[0], 0);
            imgdata.data[1] = closer(8, imgdata.data[1], 3);
            imgdata.data[2] = closer(8, imgdata.data[2], mode);

            let dataIndex = 4;
            let jump = 0;

            for (let i = 0; i < changedArray.length;) {

                imgdata.data[dataIndex] = closerArray[mode][imgdata.data[dataIndex]][changedArray[i]];
                i++;

                dataIndex++
                if (((dataIndex + 1) % 4) == 0)
                    dataIndex++;

            }

            return imgdata;
        }//enCode()

        function closer(mode, m, n) {
            let a = m % mode

            let value;

            if (255 - m <= mode / 2 || m < mode / 2) {
                value = parseInt(m / mode) * mode + n;
            } else if (n - a > mode / 2) {
                value = parseInt(m / mode) * mode + n - mode;
            } else if (a - n >= mode / 2) {
                value = parseInt(m / mode) * mode + n + mode;
            } else {
                value = parseInt(m / mode) * mode + n;
            }

            return value;
        }

        function changeBitArray(oldBit, newBit, targetArray) {

            const prefixNumber = Math.pow(2, newBit);
            const andSelectArray = (() => {
                let result = new Array(newBit - 1 + oldBit);
                for (let i = 0; i < result.length; i++)
                    result[i] = Math.pow(2, i) - 1;
                return result;
            })();

            let resultArray = new Uint8Array(Math.ceil((targetArray.length * oldBit) / newBit));
            let RAI = 0;
            let bufferNumber = 1;
            let bufferBit = 1;

            for (let i = 0; i < targetArray.length; i++) {

                bufferNumber = (bufferNumber << oldBit) + targetArray[i];
                bufferBit += oldBit;

                while ((bufferBit - 1) >= newBit) {
                    let splitBit = bufferBit - newBit - 1;
                    resultArray[RAI] = ((bufferNumber >>> splitBit) - prefixNumber);
                    RAI++;
                    bufferNumber = (1 << splitBit) + (bufferNumber & andSelectArray[splitBit]);
                    bufferBit = splitBit + 1;
                }

            }

            if (bufferBit > 1) {
                let lastest = (bufferNumber - Math.pow(2, bufferBit - 1)) << (newBit - bufferBit + 1);
                if (lastest != 0)
                    resultArray[RAI] = lastest;
            }

            return resultArray;
        }

    }//enWorker()

    //
    function deWorker() {

        onmessage = (evt) => {
            let o = evt.data;
            let feedback = { sn: evt.data.sn, value: null, error: null, time: null };
            try {
                let d1 = new Date();
                feedback.value = deCode(o.mode, o.data);
                let d2 = new Date();
                feedback.time = (d2 - d1);
            }
            catch (e) {
                feedback.error = e;
            }
            postMessage(feedback);
        }


        // 解码
        function deCode(mode, imgdata) {

            const andSelect = Math.pow(2, mode) - 1;

            let HDA = new Array(imgdata.data.length);    // hidden data array
            let HDAI = 0;

            for (let i = 4; i < HDA.length;) {

                HDA[HDAI] = imgdata.data[i] & andSelect;
                HDAI++;

                i++;
                if (((i + 1) & 3) == 0)
                    i++;

            }

            let changedArray = changeBitArray(mode, 8, HDA);

            let HDSI = changedArray.indexOf(0);

            if (HDSI == -1)
                throw new Error("解析出错:未能在数据中找到分隔码[00000000]");
            if (HDSI == 0)
                throw new Error("解析出错:数据头长度为0");

            let BHS = "";  // buffer head string
            for (let i = 0; i < HDSI; i++)
                BHS += String.fromCharCode(changedArray[i]);

            let SHS = BHS.split(String.fromCharCode(1));  // split head string
            if (SHS.length < 3)
                throw new Error("解析出错:数据头块数少于3");

            let packageLength = Number.parseInt(SHS[0]);
            if (Number.isNaN(packageLength))
                throw new Error("解析出错:数据包长度信息不是数字");

            if (changedArray.length - HDSI - 1 < packageLength)
                throw new Error("解析出错:数据长度不足");



            return [SHS, new Uint8Array(changedArray.slice(HDSI + 1, HDSI + 1 + packageLength))];

        }

        function changeBitArray(oldBit, newBit, targetArray) {

            const prefixNumber = Math.pow(2, newBit);
            const andSelectArray = (() => {
                let result = new Array(newBit - 1 + oldBit);
                for (let i = 0; i < result.length; i++)
                    result[i] = Math.pow(2, i) - 1;
                return result;
            })();

            let resultArray = new Uint8Array(Math.ceil((targetArray.length * oldBit) / newBit));
            let RAI = 0;
            let bufferNumber = 1;
            let bufferBit = 1;

            for (let i = 0; i < targetArray.length; i++) {

                bufferNumber = (bufferNumber << oldBit) + targetArray[i];
                bufferBit += oldBit;

                while ((bufferBit - 1) >= newBit) {
                    let splitBit = bufferBit - newBit - 1;
                    resultArray[RAI] = ((bufferNumber >>> splitBit) - prefixNumber);
                    RAI++;
                    bufferNumber = (1 << splitBit) + (bufferNumber & andSelectArray[splitBit]);
                    bufferBit = splitBit + 1;
                }

            }

            if (bufferBit > 1) {
                let lastest = (bufferNumber - Math.pow(2, bufferBit - 1)) << (newBit - bufferBit + 1);
                if (lastest != 0)
                    resultArray[RAI] = lastest;
            }

            return resultArray;
        }

    }//deWorker()

    /* ------------------------------------------------------------------------------------- */

    function utf8Encode(string) {
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    }

    function utf8Decode(inputStr) {
        var outputStr = "";
        var code1, code2, code3, code4;
        for (var i = 0; i < inputStr.length; i++) {
            code1 = inputStr.charCodeAt(i);
            if (code1 < 128) {
                outputStr += String.fromCharCode(code1);
            } else if (code1 < 224) {
                code2 = inputStr.charCodeAt(++i);
                outputStr += String.fromCharCode(((code1 & 31) << 6) | (code2 & 63));
            } else if (code1 < 240) {
                code2 = inputStr.charCodeAt(++i);
                code3 = inputStr.charCodeAt(++i);
                outputStr += String.fromCharCode(((code1 & 15) << 12) | ((code2 & 63) << 6) | (code3 & 63));
            } else {
                code2 = inputStr.charCodeAt(++i);
                code3 = inputStr.charCodeAt(++i);
                code4 = inputStr.charCodeAt(++i);
                outputStr += String.fromCharCode(((code1 & 7) << 18) | ((code2 & 63) << 12) | ((code3 & 63) << 6) | (code2 & 63));
            }
        }
        return outputStr;
    }

    function toLog(eid) {
        if (eid == null)
            throw new Error("eid is null");
        let e = document.getElementById(eid);
        if (e == null)
            throw new Error("element with id [" + eid + "] not found");
        return {
            log: function (text) {
                let t = document.createElement("p");
                let d = new Date();
                t.innerText = " [" + d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() + "] " + text;
                e.appendChild(t);
            }
        };

    }

    class MarkFileReader extends FileReader {

        constructor(mark) {
            super();
            this.mark = mark;
        }

    }

    /* ------------------------------------------------------------------------------------- */

    /*
        如果你有兴趣研究无影坦克，下面有一些函数可以帮助你搭建代码实验场
        记得把 enWorker() 和 deWorker() 里的东西带过去( onmessage 不是必要的 )
        使用例子:
        {

            let mode = 5;
            let infoLength = 2;

            let head = getInfoHead(2,"a","b");
            let infoDef = getRandomInfoData(infoLength);
            let idDef = getRandomImageData(4, 4);

            let idOut = enCode(mode, idDef.clone(), head, infoDef);
            let infoSol = deCode(idOut.data[2] % 8, idOut);

            let dataError = 0;
            for (i = 0; (i < infoDef.length && i < infoSol[1].length); i++) 
                if (infoDef[i] != infoSol[1][i])
                    dataError++;
        
        }

    */



    //  用于生成里件标识头
    function getInfoHead(fileLength, fileName, fileType) {
        return [fileLength, fileName, fileType].join(String.fromCharCode(1)) + String.fromCharCode(0);
    }


    //  用于生成随机里件数据
    function getRandomInfoData(length) {
        let array = new Uint8Array(length);
        for (i = 0; i < length; i++) { array[i] = getRandomInt(0, 255); }
        return array;
    }


    //  用于生成随机表图数据
    function getRandomImageData(width, height) {

        let id = new ImageData(width, height);

        for (i = 0; i < (width * height); i++) {
            id.data[4 * i + 0] = getRandomInt(0, 255);  // R
            id.data[4 * i + 1] = getRandomInt(0, 255);  // G
            id.data[4 * i + 2] = getRandomInt(0, 255);  // B
            id.data[4 * i + 3] = 255;                   // A
        }

        return {
            self: () => { return id; },
            clone: () => {
                let nid = new ImageData(id.width, id.height);
                nid.data.set(id.data);
                return nid;
            }
        };

    }


    // 用于提供随机整数
    function getRandomInt(min, max) {
        return parseInt(Math.random() * (max - min + 1)) + min;
    }


</script>

</html>